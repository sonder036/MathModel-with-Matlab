# matlab学习笔记

> 写在前面：使用matlab版本为2022a，本文参考清风数学建模教程，主要面向有一定编程基础的同学，主要记录针对美赛备赛的一些matlab函数及代码，没有详尽介绍matlab编译器的使用及一些基础知识，不建议作为入门教程学习。
----
> [TOC] 
***

## matlab 入门

> F1可以开启详尽的帮助文档。

### 简单指令与快捷键

- 运行：`F5`
- 中断运行：`Ctrl+C`
- 执行选中代码段：`F9`

- 注释：`%` 			快捷键：添加注释 `Ctrl+R`  取消注释 `Ctrl+T`

- 缩进快捷键： 	添加缩进 `Tab` 减少缩进  `Shift+Tab` 这两个也可以替换为 `Ctrl+[` 和 `Ctrl+]`

- 其余一些简单文本编辑指令此处不再赘述。

###  数据类型与基本运算

#### 数据类型

- 数值型：包含整型和浮点型，矩阵默认双精度浮点 `double`

- 文本型：包含字符型 `char` 和字符串 `string`

- 逻辑型(logical)：包含 `true` 和 `false`

- 元胞数组类型(cell)：存放任一数据类型的数组，元胞数组可存放多种数据类型的数组。

#### 数值型基本运算与函数

​	数值型基本运算包括 + - * / ^

​	以下是对于数值型的基本函数。

| 函数名     | 功能                                 |
| ---------- | ------------------------------------ |
| abs(x)     | 计算x的绝对值，如果x为复数则计算模长 |
| floor(x)   | 向下取整                             |
| ceil(x)    | 向上取整                             |
| round(x,n) | 对x四舍五入，n表示保留位数           |
| mod(x,m)   | 计算x除以m的余数                     |
| sqrt(x)    | 计算x的平方根                        |

#### 特殊变量


|   特殊变量   | 描述     |
| --- | --- |
|   ans   |   默认保存运算结果的变量名   |
|   pi|  圆周率    |
|   NaN   |   不定值或缺失值   |
|   inf/-inf   |   正负无穷大   |
|   eps   |   浮点相对精度  |
| i 和 j | 虚数单位 |

### 向量与矩阵基本操作

#### 矩阵与向量的创建

矩阵需用`[]`括起来，同一行元素用 `,` 或 ` ` 隔开，换行需用 `;` 隔开。则只有 `,` 或 ` ` 为行向量，只有 `;` 为列向量。

我们可以使用 `:` 来生成一串用空格分开的连续的数，具体使用方法如下表所示。

| 代码  | 解释                                        |
| ----- | ------------------------------------------- |
| a:b   | 首项为a每次增加1，直到不大于b的最大值的数列 |
| a:k:b | 首项为a每次增加k，直到不越过b的最大值的数列 |

`越过` 是因为 `k`可为负值，下面是简单的代码示例：

```matlab
a=[1.5:7.5]		%a = [1.5000 2.5000 3.5000 4.5000 5.5000 6.5000 7.5000]
a=[2:2:9]		%a = [2 4 6 8]
a=[45:-3.5:25]	%a = [45.0000 41.5000 38.0000 34.5000 31.0000 27.5000]
```

### 基础语法

#### 输入输出

##### 输入

```matlab
x=input(prompt)
```

`prompt` 为提示用户输入内容的文本。

##### 输出

```matlab
disp(X)
```

`X` 为输出内容，可为任意数据类型。

#### 选择结构

```matlab
if 判断语句
	...
end
```

```matlab
if 判断语句
	...
else
	...
end
```

```matlab
if 判断语句
	...
elseif 判断语句
	...
else
	...
end
```

#### 循环结构

```matlab
for 循环体 
	...
end
```

```matlab
while 判断条件
	...
end
```

### 常用指令

| 常用指令      | 描述                                         |
| ------------- | -------------------------------------------- |
|clc|清空命令行窗口|
| clear         | 清空工作区                                   |
| format long g | 显示完整输出格式(完整小数)                   |
| toc tic       | 在两者间编写代码，运行后会输出代码的运行时间 |

## 算法

### 评价类算法

#### 层次分析法----AHP

主要用于解决评价类问题（例如：选择哪种方案最好、哪位运动员或者员工表现的更优秀）。

1. 建立评价体系
2. 建立判断矩阵并计算
3. 对判断矩阵进行一致性检验
  - 计算一致性指标
  - 查找对应的平均随机一致性指标$CI$
  - 计算一致性比例 $CR=\frac{CI}{RI}$
  - 计算权重

```matlab
A=input('输入判断矩阵:');                % 输入判断矩阵
%% 计算一致性比例CR
n=size(A,1);                            %求出判断矩阵阶数
[V,D]=eig(A);                           %求出特征值和特征向量
Max_eig=max(D(:));                      %找出最大特征值
CI=(Max_eig-n)/(n-1);                   %计算一致性指标
RI=[0 0 0.52 0.89 1.12 1.26 1.36];      %列出平均随机一致性指标
CR=CI/RI(n);                            %求出一致性比例
if(CR<0.1)                              %判断一致性是否能接受
    disp("一致性可以接受!");
else
    disp("一致性检验未通过，需要修改判断矩阵!");
end
%% 方法一：算数平均法求权重
Product_A=sum(A,2);                    %将判断矩阵每行相乘
Product_n_A=Product_A./n;              %求几何平均值
w_ari=Product_n_A./sum(Product_n_A);   %将其标准化
disp('算数平均值值法求权重结果为:');     %输出结果
disp(w_ari);    
%% 方法二：几何平均法求权重
Product_B=prod(A,2);                    %将判断矩阵每行相乘
Product_n_B=Product_B.^(1/n);           %求几何平均值
w_geo=Product_n_B./sum(Product_n_B);    %将其标准化
disp('几何平均值值法求权重结果为:');      %输出结果
disp(w_geo);             
%% 方法三：特征值法求权重
[r,c]=find(D==Max_eig,1);               %找到最大特征值的位置
w_eig=V(:,c)./sum(V(:,c));              %找到相应的特征向量，并将其标准化
disp('特征值法求权重结果为:');            %输出结果
disp(w_eig); 
```

#### 优劣解距离法----TOPSIS

TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息， 其结果能精确地反映各评价方案之间的差距

```matlab
%%步骤一：读取数据  
clear;clc  
load data_water_quality.mat                      %读取数据  
[r,c]=size(X);  
disp('····················读取数据成功····················');  
disp(['评价对象数量为：',num2str(r)]);  
disp(['评价指标数量为：',num2str(c)]);  
%%步骤二：对指标进行正向化处理  
disp('····················进行正向化处理····················');  
Type=input('请按顺序输入各列指标类型：1.极大型 2.极小型 3.中间型 4.区间型:'); 
for i = 1:c  
    if Type(i)==1  
        disp(['第' num2str(i) '列是极大型，无需正向化'] );  
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~');  
    elseif Type(i)==2  
        disp(['第' num2str(i) '列是极小型，进行正向化'] );  
        Maxx=max(X);                          %找出最大值  
        for j = 1:r                           %进行正向化  
            X(j,i)=Maxx(i)-X(j,i);  
        end  
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~');  
    elseif Type(i)==3  
        disp(['第' num2str(i) '列是中间型，进行正向化'] );  
        best=input('请输入最优值：');                                       %7  
        M=max(abs(X(:,i)-best));             %找出距离最优值最远距离  
        for j = 1:r                          %进行正向化  
            X(j,i)=1-abs(X(j,i)-best)/M;  
        end  
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~');  
    elseif Type(i)==4  
        disp(['第' num2str(i) '列是区间型，进行正向化'] );  
        L=input('请输入最优区间下界：');                                    %10  
        R=input('请输入最优区间上界：');                                    %20  
        M=0;  
        for j = 1:r                         %找出距离最优区间最远距离  
            if X(j,i)<L  
                M=max(M,L-X(j,i));  
            elseif X(j,i)>R  
                M=max(M,X(j,i)-R);  
            end  
        end    
        for j = 1:r                         %进行正向化  
            if X(j,i)<L  
                X(j,i)=1-(L-X(j,i))/M;  
            elseif X(j,i)>R  
                X(j,i)=1-(X(j,i)-R)/M;  
            else  
                X(j,i)=1;  
            end  
        end    
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~');  
    else  
        disp('没有预设处理该类型的指标，请检查输入是否正确。');  
    end  
end  
disp('····················正向化处理完成····················');  
disp('··················正向化处理后矩阵为···················');  
disp(X);  
%%步骤三：处理指标权重  
judge_flag=input('如果需要对指标加入权重输入1，否则输入0：');            %0  
if judge_flag==1  
    weight=input('请按顺序输入每个指标的权重(注意权重和应为1)：');             %[0.2,0.2,0.3,0.3]  
    flag=0;  
    while flag==0                               %判断指标权重是否合法 
        if(abs(sum(weight)-1)<0.0000001 && size(weight,1)==1 && size(weight,2)==c )  
            flag=1;  
        else  
            weight=input('输入有误，请重新输入：');  
        end  
    end  
else  
    weight=ones(1,c)./c;  
end  
%%步骤四：化为标准化矩阵  
disp('··················标准化处理后矩阵为···················');  
Z=X./repmat(sum(X.*X) .^ 0.5,r,1);              %将矩阵标准化处理  
disp(Z);  
%%步骤五：计算得分  
D_max=sum([ (Z - repmat(max(Z),r,1)) .^ 2 ] .* repmat(weight,r,1) ,2) .^0.5;  
D_min=sum([ (Z - repmat(min(Z),r,1)) .^ 2 ] .* repmat(weight,r,1) ,2) .^0.5;  
Grade=D_min./(D_max+D_min);                     %计算出未归一化得分  
Grade=Grade./sum(Grade);                        %将得分归一化  
```

#### 模糊综合评价

##### 概述

​	生活中处处存在模糊性，与确定性相对。如性别，身高，体重等定量概念是确定性概念；而帅，高，年轻等概念为模糊性概念。

​	模糊数学⼜称 Fuzzy 数学，是研究和处理模糊性现象的⼀种数学理论和⽅法。模糊性数学发展的主流是在它的应⽤⽅⾯。 由于模糊性概念已经找到了模糊集的描述⽅式，⼈们运⽤概念进⾏判断、评价、推理、决策和控制的过程也可以⽤模糊性数 学的⽅法来描述。例如模糊聚类分析、模糊模式识别、模糊综合评判、模糊决策与模糊预测、模糊控制、模糊信息处理等。 这些⽅法构成了⼀种模糊性系统理论，构成了⼀种思辨数学的雏形，它已经在医学、⽓象、⼼理、经济管理、⽯油、地质、 环境、⽣物、农业、林业、化⼯、语⾔、控制、遥感、教育、体育等⽅⾯取得具体的研究成果。

##### 经典集合和模糊集合的基本概念

1. 经典集合和特征函数

   经典集合承认非此即彼，用特征函数刻画经典集合。
   $$
   f_A:\Omega \to \{ 0,1 \}\\
   \Omega: 论域（讨论对象的集合）\\
   f_A 表示A集合的特征函数\\
   f_A=
   \begin{cases}
    1\ \ \ x\in A \\
    0\ \ \ x\notin A
   \end{cases}
   \ \ \ \ \forall x \in \Omega
   $$

2. 模糊集合和隶属函数

   模糊结合承认亦此亦彼，用隶属函数刻画模糊集合。
   $$
   u_A:\Omega \to [ 0,1 ]\\
   \Omega: 论域（讨论对象的集合）\\
   u_A 表示A集合的隶属函数，值对应隶属度\\
   $$
   表示方法：
   $$
   论域\ \ \Omega =\{x_1,x_2,...x_n \},\ 模糊集合为\ A,\ 隶属度为\ A(x_i),\ i=1,2,...,n\\
   Zadeh表示法:\ A=\sum^{n}_{i=1} \frac{A(x_i)}{x_i}\\
   序偶表示法:\ A=\{(x_1,A(x_1)),(x_2,A(x_2)),...,(x_n,A(x_n))\}
   $$

##### 隶属函数的确定方法

1. 借助已有的客观尺度 (需要有合适的指标，并能收收集到数据)

   这里找到的指标必须归一化，下面是一些例子。

   |    论域  |  模糊集    |   隶属度   |
   | ---- | ---- | ---- |
   |   设备   |  设备完好    |   设备完好率   |
   |   产品   |   质量稳定   |    良品率  |
   |   家庭   |   小康家庭   |    恩格尔系数  |
   
2. 指派法

   根据问题的性质直接套⽤某些分布 作为⾪属函数，主观性较强，优点是比较方便。

![image-20240129202442569](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240129202442569.png)

##### 模糊综合评价问题概述

​		模糊评价问题是要把论域中的对象对应评语集中⼀个指定的评语或者将⽅案作为评语集并选择⼀个最优的⽅案。

在模糊综合评价中引⼊了三个集合：

- 因素集（评价指标集）：$\Omega = \{u_1,u_2,...,u_n\}$
- 评语集（评价的结果）：$V = \{v_1,v_2,...,v_n\}$
- 权重集（指标的权重）：$A = \{a_1,a_2,...,a_n\}$

例如要评价一名学生的表现：

- 因素集：$\Omega = \{专业排名,\ 科研竞赛,\ 志愿活动,\ 课外实践\}$
- 评语集：$V = \{优\ 良\ 差\}$
- 权重集：$A = \{0.5,\ 0.3,\ 0.1,\ 0.1\}$

一级模糊综合评判模型的建立，主要包括以下步骤：

1. 确立因素集
2. 确立评语集
3. 确定各因素的权重
4. 确定模糊综合判断矩阵
5. 综合评判



### 插值与拟合算法

#### 插值算法

​		高次插值会产生龙格现象，即两端伯渎极大，产生明显的震荡。在不熟悉曲线的运动趋势的前提下，不要轻易使用高次插值。于是引入分段插值。

##### 分段三次Hermite插值----PCHIP

```matlab
x=-pi:pi,y=sin(x);
new_x=-pi:0.1:pi
new_y=pchip(x,y,new_x);
plot(x,y,'ro');
hold on;%% 保留窗口，让下一张图在窗口上继续画，这三行也可以写为 plot(x,y,'ro',new_x,new_y,'-b');
plot(new_x,new_y,'-b');
%% plot参数
%% 线方式:  -实线 :点线 -.虚点线 --波折线d
%% 点方式:  .圆点 +加号 *星号 x x形 o小圆
%% 颜色: y黄 r红 g绿 b蓝 k黑
```

##### 分段三次样条插值----SPLINE

三次样条插值要求每个子区间插值函数二阶可微。

```matlab
x=-pi:pi,y=sin(x);
new_x=-pi:0.1:pi
new_y1=pchip(x,y,new_x);
new_y2=spline(x,y,new_x);
plot(x,y,'ko');
hold on;%% 保留窗口，让下一张图在窗口上继续画，这三行也可以写为 plot(x,y,'ro',new_x,new_y,'-b');
plot(new_x,new_y1,'-b');
plot(new_x,new_y2,'-r');
legend('基准点','三次埃尔米特插值','三次样条插值','Location','southeast');  
					%依次为三个点线的标识，后两个参数为表示标识位置
```

##### n维数据插值

```matlab
new_y=interpn(x1,x2,...,xn,y,new_x2,new_x2,...,new_xn,method)
```

`xi`表示基准点第 `i` 维坐标; `y`表示函数值; `new_xi`表示要插值计算的点 

 `method`表示插值法，建议使用三次样条插值 `spline`

##### 插值预测

以人口预测为例:

```matlab
populate_data=[133126 133770 134413 135069 135738 136427 137221 137866 138639 139538]
year=2009:2018
p1 = pchip(year,populate_data,2019:2021);
p2 = spline(year,populate_data,2019:2021);
plot(year,populate_data,'o',2019:2021,p1,'r*-',2019:2021,p2,'b*-');
legend('样本点','三次埃尔米特插值预测','三次样条插值预测','Location','northwest');
title('预测2019-2021人口','FontSize',15);
```

![image-20240128193140171](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240128193140171.png)

##### 利用subplot函数画多个图

```matlab
subpolt(a,b,k);
%% a,b表示未知数，画图时定义k为画图的位置
```

示例如下

```matlab
x=-pi:pi,y=sin(x);
fx=linspace(-pi,pi);    %默认在[-pi,pi]间取100个点
fy=sin(fx);

subplot(3,2,[1,2]);
plot(fx,fy,'k-',LineWidth=1.5);
hold on;
plot(x,y,'ko');
title('原函数与基准点',fontsize=15);

new_x=-pi:0.1:pi
new_y1=pchip(x,y,new_x);
new_y2=spline(x,y,new_x);
plot(x,y,'ko');
subplot(3,2,3);
plot(new_x,new_y1,'-.b',LineWidth=1.5);
title('三次埃尔米特插值',fontsize=15);

subplot(3,2,4);
plot(new_x,new_y2,'-.r',LineWidth=1.5);
title('三次样条插值',fontsize=15);

subplot(3,2,[5,6]);
plot(fx,fy,'k-',LineWidth=1.5);
hold on;
plot(x,y,'ko');
plot(new_x,new_y1,'-.b',LineWidth=1.5);
plot(new_x,new_y2,'-.r',LineWidth=1.5);
legend('原函数','基准点','三次埃尔米特插值','三次样条插值','Location','southeast'); 
title('综合对比图',fontsize=15);
```

![image-20240128192902527](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240128192902527.png)

#### 拟合算法

​		插值算法中，得到的多项式 $f(x)$ 要经过所有样本点。但是如果样本点太多，那么这个多项式次数过高，会造成龙格现象。尽管我们可以选择分段的方法避免这种现象，但是更多时候我们更倾向于得到一个确定的曲线，尽管这条曲线不能经过每一个样本点，但只要保证误差足够小即可，这就是拟合的思想。（拟合的结果是得到一个确定的曲线）

##### 匿名函数

```matlab
f=@(x) kx+b;
%% f=@(自变量列表) 函数表达式
%% 此代码即创建了一个表达式为 f=kx+b 的函数
%% fplot(f,xinterval) 可绘制一元函数图像,第一个参数是匿名函数，第二个参数放绘图区域
```

##### 最小二乘拟合 y=kx+b

$$
\hat{k}=\frac{n\sum_{i=1}^{n}x_iy_i-\sum^{n}_{i=1}y_i\sum^{n}_{i=1}x_i}{n\sum_{i=1}^{n}x_i^2-\sum^{n}_{i=1}x_i\sum^{n}_{i=1}x_i}\\
\hat{b}=\frac{\sum^{n}_{i=1}x_i^2y_i-\sum^{n}_{i=1}x_i\sum^{n}_{i=1}x_iy_i}{n\sum_{i=1}^{n}x_i^2-\sum^{n}_{i=1}x_i\sum^{n}_{i=1}x_i}
$$
评价标准：

- 总体平方和SST：$SST=\sum^{n}_{i=1}(y_i-\bar{y})^2$

- 误差平方和SSE：$SSE=\sum^{n}_{i=1}(y_i-\hat{y})^2$

- 回归平方和SSR：$\sum^{n}_{i=1}(\bar{y}-\hat{y})^2$

- 拟合优度：$0 \le R^2=\frac{SSR}{SST}=1-\frac{SSE}{SST} \le 1$

$R^2$ 越接近1，拟合效果越好，改评价标准只适用于线性函数。如果比较两种函数的拟合好坏时，直接对比 $SSE$ 即可。

```matlab
load data1.mat
plot(x,y,'ko');
xlabel('x的值');
ylabel('y的值');
hold on;
grid on;    %显示网格

n=size(x,1);
k=(n*sum(x.*y)-sum(x)*sum(y))/(n*sum(x.*x)-sum(x)*sum(x));
b=(sum(x.*x)*sum(y)-sum(x)*sum(x.*y))/(n*sum(x.*x)-sum(x)*sum(x));
f=@(new_x) k*new_x+b;
fplot(f,[min(x),max(x)],'b-',LineWidth=1.5);
legend('基准点','拟合直线',Location='northwest');
title('最小二乘拟合','FontSize',15);

y_hat=k*x+b;
SSR=sum((y_hat-mean(y)).^2)
SSE=sum((y_hat-y).^2)
SST=SSE+SSR
R_2=SSR/SST
```

![image-20240129012651971](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240129012651971.png)

##### matlab曲线拟合工具箱cftool

![image-20240129022512652](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240129022512652.png)

![image-20240129022727339](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240129022727339.png)

还有其他选项可自行尝试。另外导出可以选择导出代码，但是导出代码输出的图示跟在`cftool`上显示效果有一些差别，下面是用代码导出的拟合图形（又加入了残差图），也可以稍加带动用拟合的函数进行`预测`。

```matlab
function [fitresult, gof] = createFit(x, y)
%CREATEFIT(X,Y)
%  创建一个拟合。
%
%  要进行 '线性函数拟合' 拟合的数据:
%      X 输入: x
%      Y 输出: y
%  输出:
%      fitresult: 表示拟合的拟合对象。
%      gof: 带有拟合优度信息的结构体。
%
%  另请参阅 FIT, CFIT, SFIT.

%  由 MATLAB 于 29-Jan-2024 02:31:13 自动生成


%% 拟合: '线性函数拟合 1'。
[xData, yData] = prepareCurveData( x, y );

% 设置 fittype 和选项。
ft = fittype( 'poly1' );

% 对数据进行模型拟合。
[fitresult, gof] = fit( xData, yData, ft );

% 为绘图创建一个图窗。
figure( 'Name', '线性函数拟合 1' );

% 绘制数据拟合图。
subplot( 2, 1, 1 );
h = plot( fitresult, xData, yData, 'predobs' );
legend( h, 'y vs. x', '线性函数拟合 1', '下界(线性函数拟合 1)', '上界(线性函数拟合 1)', 'Location', 'NorthEast', 'Interpreter', 'none' );
% 为坐标区加标签
xlabel( 'x', 'Interpreter', 'none' );
ylabel( 'y', 'Interpreter', 'none' );
grid on

% 绘制残差图。
subplot( 2, 1, 2 );
h = plot( fitresult, xData, yData, 'residuals' );
legend( h, '线性函数拟合 1 - 残差', 'Zero Line', 'Location', 'NorthEast', 'Interpreter', 'none' );
% 为坐标区加标签
xlabel( 'x', 'Interpreter', 'none' );
ylabel( 'y', 'Interpreter', 'none' );
grid on
```

![image-20240129023609225](C:\Users\11786\AppData\Roaming\Typora\typora-user-images\image-20240129023609225.png)

### 系统分析算法

> ​		一般的抽象系统,如社会系统、经济系统、农业系统、生态系统、教育系统等都包含有许多种因素，多种因素共同作用的结果决定了该系统的发展态势。人们常常希望知道在众多的因素中，哪些是主要因素，哪些是次要因素；哪些因素对系统发展影响大，哪些因素对系统发展影响小；哪些因素对系统发展起推动作用需强化发展，哪些因素对系统发展起阻碍作用需加以抑制······这些都是系统分析中人们普遍关心的问题。例如,粮食生产系统，人们希望提高粮食总产量，而影响粮食总产量的因素是多方面的，有播种面积以及水利、化肥、土壤、种子、劳力、气候、耕作技术和政策环境等。为了实现少投入多产出，并取得良好的经济效益、社会效益和生态效益,就必须进行系统分析。

#### 灰色关联分析

##### 概述

数理统计中的回归分析、方差分析主成分分析等都是用来进行系统分析的方法。这些方法都有下述不足之处:

- 要求有大量数据,数据量少就难以找出统计规律

- 要求样本服从某个典型的概率分布,要求各因素数据与系统特征数据之间呈线性关系且各因素之间彼此无关,这种要求往往难以满足

- 计算量大,一般要靠计算机帮助

- 可能出现量化结果与定性分析结果不符的现象,导致系统的关系和规律遭到歪曲和颠倒

  ​		灰色关联分析方法弥补了采用数理统计方法作系统分析所导致的缺憾.它对样本量的多少和样本有无规律都同样适用，而且计算量小，十分方便，更不会出现量化结果与定性分析结果不符的情况。
  ​		灰色关联分析的基本思想是根据序列曲几何形状的相似程度来判断其联系是否紧密.曲线越接近，相应序列之间的关联度就越大，反之就越小。
  ​		对一个抽象的系统或现象进行分析，首先要选准反映系统行为特征的数据序列，称为找系统行为的映射量，用映射量来间接地表征系统行为.例如，用国民平均接受教育的年数来反映教育发达程度，用刑事案件的发案率来反映社会治安面貌和社会秩序，用医院挂号次数来反映国民的健康水平等.有了系统行为特征数提和相关因老的救据可作中冬个序列的图形从观上进行分析。
  
  > 当样本个体数较大时，一般用标准化回归，反正用灰色关联分析。

##### 步骤

1. 画统计图做出简单分析

2. 确定分析序列

   母序列（参考序列，母指标）：能反映系统行为特征的序列，类似于因变量 $Y$ ，此处记为 $X$

   子序列（比较序列，子指标）：能反映系统行为因素组成的序列，类似于自变量 $X$ ，此处记为 $x_1,x_2,...,x_n$
   
3. 对变量进行预处理（去除量纲，缩小变量范围简化计算）

   对母序列和子序列分别进行预处理：先求出每个指标的均值，在用该指标中每个元素除以其均值。

4. 计算子序列各个指标和母指标的关联系数

   记录两极最小差 $a$ 和两极最大差 $b$ 
   $$
   a=min_i\{min_k|X(k)-x_i(k)|\} \\
   b=max_i\{max_k|X(k)-x_i(k)|\} \\
   $$
   定义关联系数：
   $$
   \gamma(X(k),x_i(k))=\frac{a+\rho b}{|X(k)-x_i(k)|+\rho b}\ \ \ \ \ \ \ \rho 为分辨系数，一般取0.5
   $$
   
5. 定义 $X$ 和 $x_i$ 灰色关联度：
   $$
   \gamma (X,x_i)=\frac{1}{n} \sum^{n}_{k=1}\gamma (X(k),x_i(k))
   $$
   
6. 通过比较子序列和母序列的关联度得出结论：

   灰色关联度最大的子序列对母序列影响最大。

#### 代码

```matlab
load gdp.mat;
Mean=mean(gdp);
gdp=gdp./repmat(Mean,size(gdp,1),1);    %将Mean复制为size(gdp,1)行的矩阵
disp('预处理后矩阵为:');
disp(gdp);

Y=gdp(:,1);                             %第一列为母序列
X=gdp(:,2:end);                         %其余列为子序列
abs_X_Xi=abs(X-repmat(Y,1,size(X,2)));  %计算|X-xi|矩阵
a=min(min(abs(abs_X_Xi)));              %计算两极最小差
b=max(max(abs(abs_X_Xi)));              %计算两极最大差
rho=0.5;                                %定义分辨系数
gamma=(a+rho*b)./(abs_X_Xi+rho*b);      %计算关联系数
disp('各子序列灰色关联度为:')
disp(mean(gamma));
```

### 回归分析

> ​		回归分析是数据分析中最基础也是最重要的分析工具，绝大多数的 数据分析问题，都可以使用回归的思想来解决。回归分析的任务就是， 通过研究自变量X和因变量Y的相关关系，尝试去解释Y的形成机制，进而达到通过X去预测Y的目的。 常见的回归分析有五类：线性回归、0‐1回归、定序回归、计数回归和生存回归，其划分的依据是因变量Y的类型。本讲我们主要学习线性回归。

##### 回归分析的使命

- 回归分析要去识别并判断：哪些$X$变量是同$Y$真的相关，哪些不是。 统计学中有一个非常重要的领域，叫做“变量选择”。（逐步回归法）
- 去除了那些同$Y$不相关的$X$变量，那么剩下的，就都是重要的、有用的$X$变量了。接下来回归分析要回答的问题是：这些有用的$X$变量同$Y$的相关 关系是正的呢，还是负的？
- 在确定了重要的$X$变量的前提下，我们还想赋予不同$X$不同的权重， 也就是不同的回归系数，进而我们可以知道不同变量之间的相对重要性。

##### 数据的分类

- 横截面数据：在某一时点收集的不同对象的数据。

  ​	（1）我们自己发放问卷得到的数据 

  ​	（2）全国各省份2018年GDP的数据 

  ​	（3）大一新生今年体测的得到的数据

- 时间序列数据：对同一对象在不同时间连续观察所取得的数据。

  ​	（1）从出生到现在，你的体重的数据（每年生日称一次)。 

  ​	（2）中国历年来GDP的数据。 

  ​	（3）在某地方每隔一小时测得的温度数据。

- 面板数据：横截面数据与时间序列数据综合起来的一种数据资源。

  ​	2008‐2018年，我国各省份GDP的数据。

| 数据类型     | 常见建模方法                                |
| ------------ | ------------------------------------------- |
| 横截面数据   | 多元线性回归                                |
| 时间序列数据 | 移动平均，指数平滑，ARIMA，CARCH，VAR，协积 |
| 面板数据     | 固定效应和随机效应，静态面板和动态面板      |

前两种数据类型最常考到；面板数据较为复杂，是经管类学生在中级计量经济学中才会学到的模型。 横截面数据往往可以使用回归来进行建模，我们通过回归可以得到自变量与因变量之间的相关关系以及自变量的重要程度。 时间序列数据往往需要进行我们进行`预测`，时间序列模型的选择也很多， 大家需要选择合适的模型对数据进行建模。


#### 一元线性回归分析

内容近似为线性拟合。
